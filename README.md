# SpringBoardTeam7

## [Chapter 3-3] 주특기 심화 (W5)

<br/>

### Spring 심화 주차 팀 과제 LV2
"Spring Security를 적용한 나만의 항해 블로그 백엔드 서버 만들기"

<br/>
<br/>

### API 명세서
https://documenter.getpostman.com/view/24654255/2s8YzWTh4i

### ERD
https://www.erdcloud.com/d/yDSBNgTLLtDGW2NfE

### 추가된 요구 사항

1. 숙련주차 개인과제 LV2 프로젝트에 Spring Security 적용하기
2. 게시글 좋아요 API
   - 사용자는 선택한 게시글에 ‘좋아요’를 할 수 있습니다.
   - 사용자가 이미 ‘좋아요’한 게시글에 다시 ‘좋아요’ 요청을 하면 ‘좋아요’를 했던 기록이 취소됩니다.
   - 요청이 성공하면 Client 로 성공했다는 메시지, 상태코드 반환하기
3. 댓글 좋아요 API
   - 사용자는 선택한 댓글에 ‘좋아요’를 할 수 있습니다.
   - 사용자가 이미 ‘좋아요’한 댓글에 다시 ‘좋아요’ 요청을 하면 ‘좋아요’를 했던 기록이 취소됩니다.
   - 요청이 성공하면 Client 로 성공했다는 메시지, 상태코드 반환하기
4. [예외처리](https://www.notion.so/Spring-LV2-b50caffec1ca471e84b6c306474ae229)
   - 아래 예외처리를 AOP 를 활용하여 구현하기

<br/>

<details>
<summary>기존의 요구 사항</summary>

1. 회원 가입 API
   - username, password를 Client에서 전달받기
   - username은  `최소 4자 이상, 10자 이하이며 알파벳 소문자(a~z), 숫자(0~9)`로 구성되어야 한다.
   - password는  `최소 8자 이상, 15자 이하이며 알파벳 대소문자(a~z, A~Z), 숫자(0~9), 특수문자`로 구성되어야 한다.
   - DB에 중복된 username이 없다면 회원을 저장하고 Client 로 성공했다는 메시지, 상태코드 반환하기
   - 회원 권한 부여하기 (ADMIN, USER) - ADMIN 회원은 모든 게시글, 댓글 수정 / 삭제 가능
   - 참고자료
      1. [https://mangkyu.tistory.com/174](https://mangkyu.tistory.com/174)
      2. [https://ko.wikipedia.org/wiki/정규_표현식](https://ko.wikipedia.org/wiki/%EC%A0%95%EA%B7%9C_%ED%91%9C%ED%98%84%EC%8B%9D)
      3. [https://bamdule.tistory.com/35](https://bamdule.tistory.com/35)

2. 로그인 API
   - username, password를 Client에서 전달받기
   - DB에서 username을 사용하여 저장된 회원의 유무를 확인하고 있다면 password 비교하기
   - 로그인 성공 시, 로그인에 성공한 유저의 정보와 JWT를 활용하여 토큰을 발급하고,
     발급한 토큰을 Header에 추가하고 성공했다는 메시지, 상태코드 와 함께 Client에 반환하기
3. 전체 게시글 목록 조회 API
   - 제목, 작성자명(username), 작성 내용, 작성 날짜를 조회하기
   - 작성 날짜 기준 내림차순으로 정렬하기
   - 각각의 게시글에 등록된 모든 댓글을 게시글과 같이 Client에 반환하기
   - 댓글은 작성 날짜 기준 내림차순으로 정렬하기
   - 게시글/댓글에 ‘좋아요’ 개수도 함께 반환하기
4. 게시글 작성 API
   - ~~토큰을 검사하여, 유효한 토큰일 경우에만 게시글 작성 가능~~  ⇒ Spring Security 를 사용하여 토큰 검사 및 인증하기!
   - 제목, 작성자명(username), 작성 내용을 저장하고
   - 저장된 게시글을 Client 로 반환하기
5. 선택한 게시글 조회 API
   - 선택한 게시글의 제목, 작성자명(username), 작성 날짜, 작성 내용을 조회하기
     (검색 기능이 아닙니다. 간단한 게시글 조회만 구현해주세요.)
   - 선택한 게시글에 등록된 모든 댓글을 선택한 게시글과 같이 Client에 반환하기
   - 댓글은 작성 날짜 기준 내림차순으로 정렬하기
   - 게시글/댓글에 ‘좋아요’ 개수도 함께 반환하기
6. 선택한 게시글 수정 API
   - ~~토큰을 검사한 후, 유효한 토큰이면서 해당 사용자가 작성한 게시글만 수정 가능~~  ⇒ Spring Security 를 사용하여 토큰 검사 및 인증하기!
   - 제목, 작성 내용을 수정하고 수정된 게시글을 Client 로 반환하기
   - 게시글에 ‘좋아요’ 개수도 함께 반환하기
7. 선택한 게시글 삭제 API
   - ~~토큰을 검사한 후, 유효한 토큰이면서 해당 사용자가 작성한 게시글만 삭제 가능~~  ⇒ Spring Security 를 사용하여 토큰 검사 및 인증하기!
   - 선택한 게시글을 삭제하고 Client 로 성공했다는 메시지, 상태코드 반환하기
8. 댓글 작성 API
   - ~~토큰을 검사하여, 유효한 토큰일 경우에만 댓글 작성 가능~~  ⇒ Spring Security 를 사용하여 토큰 검사 및 인증하기!
   - 선택한 게시글의 DB 저장 유무를 확인하기
   - 선택한 게시글이 있다면 댓글을 등록하고 등록된 댓글 반환하기
9. 댓글 수정 API
   - ~~토큰을 검사한 후, 유효한 토큰이면서 해당 사용자가 작성한 댓글만 수정 가능~~  ⇒ Spring Security 를 사용하여 토큰 검사 및 인증하기!
   - 선택한 댓글의 DB 저장 유무를 확인하기
   - 선택한 댓글이 있다면 댓글 수정하고 수정된 댓글 반환하기
   - 댓글에 ‘좋아요’ 개수도 함께 반환하기
10. 댓글 삭제 API
   - ~~토큰을 검사한 후, 유효한 토큰이면서 해당 사용자가 작성한 댓글만 삭제 가능~~  ⇒ Spring Security 를 사용하여 토큰 검사 및 인증하기!
   - 선택한 댓글의 DB 저장 유무를 확인하기
   - 선택한 댓글이 있다면 댓글 삭제하고 Client 로 성공했다는 메시지, 상태코드 반환하기
11. 예외 처리
   - 토큰이 필요한 API 요청에서 토큰을 전달하지 않았거나 정상 토큰이 아닐 때는 "토큰이 유효하지 않습니다." 라는 에러메시지와 statusCode: 400을 Client에 반환하기
   - 토큰이 있고, 유효한 토큰이지만 해당 사용자가 작성한 게시글/댓글이 아닌 경우에는 “작성자만 삭제/수정할 수 있습니다.”라는 에러메시지와 statusCode: 400을 Client에 반환하기
   - DB에 이미 존재하는 username으로 회원가입을 요청한 경우 "중복된 username 입니다." 라는 에러메시지와 statusCode: 400을 Client에 반환하기
   - 로그인 시, 전달된 username과 password 중 맞지 않는 정보가 있다면 "회원을 찾을 수 없습니다."라는 에러메시지와 statusCode: 400을 Client에 반환하기
   - 회원가입 시 username과 password의 구성이 알맞지 않으면 에러메시지와 statusCode: 400을 Client에 반환하기

<div markdown="1">
</div>
</details>
<details>
<summary>체크 리스트</summary>
<div markdown="1">

<aside>
✅ Spring / Api

- [X]  controller, service, repository를 잘 분리하였는지
- [X]  dto를 잘 사용하고 있는지
- [X]  api의 request와 response는 적절한지
- [X]  query param, path param, body를 잘 사용하고 잇는지
- [X]  restful api 설계규칙에 부합하는지
</aside>

<aside>
✅ JPA

- [ ]  엔티티 Column들의 제약조건을 잘 설정했는지(nullable, unique 등)
- [ ]  엔티티 사이에 적절한 연관관계를 설정했는지(1:N/1:1/N:N, 양방향/단방향 등)
- [ ]  트랜젝션 단위를 잘 설정했는지, @Transactional이 필요한 곳에 사용되었는지
</aside>

<aside>
✅ Java

- [X]  변수와 메서드의 네이밍은 적절한지
- [X]  변수와 상수를 적절하게 사용하였는지, 하드코딩은 없는지
- [X]  인스턴스를 생성하거나 수정하는 방법은 적절한지(키워드 : 생성자, setter, builder 등)
- [X]  동일한 코드가 반복되는 부분은 없는지
- [ ]  접근제어자를 잘 사용하고 있는지
- [ ]  Lombok 어노테이션으로 처리한 메서드가 있다면 어떤 기능을 하고 있는지 잘 이해하고 있는지, 적절하게 사용하였는지(@Getter, @Setter, @NoArgsConstructor, @AllArgsConstructor, @RequiredArgsConstructor 등)
   - 어노테이션을 사용하지 않고 자바코드로 구현할 수 없다면, 먼저 코드로 구현해보세요!
</aside>

</div>
</details>


<details>
<summary>심화 질문 1 및 답변</summary>
<div markdown="1">

1. Spring Security를 적용했을 때 어떤 점이 도움이 되셨나요?
> 처음으로 사용해서 이 답변을 쓰는 지금까지도 명확하게 이해를 하고 쓰는 상황은 아닌게 현재 상황입니다. <br/>
> 다만, 기존의 JWT 토큰만을 사용했던것에 비해서 서비스단의 코드가 훨씬 간결해져서 개발 진행에 있어서 훨씬 편했습니다. <br/>
> 지원해주는 기능이 아주 다양한 만큼 공부가 많이 필요해 보입니다.
2. IoC / DI 에 대해 간략하게 설명해 주세요!  - 숙련주차의 답변을 Upgrade 해 주세요!
> Ioc(Inversion of Control) <br/>
> 제어의 역전 이라는 의미로, 메소드나 객체의 호출 작업을 개발자가 정하는것이 아닌 외부에서 결정되는 것을 말한다. <br/>
> 이를 통해 의존성을 역전시켜 객체 간의 결합도를 줄이고 유연한 코드의 작성이 가능해진다. <br/>
> 또한, 가독성 및 코드 중복 방지 및 유지 보수에 있어서 편하게 가능해진다.

> DI(Dependency Injection) <br/>
> 스프링이 다른 프레임워크와 차별화되어 제공하는 의존 관계 주입 기능으로,
> 객체를 직접 생성하는 것이 아니라 외부에서 생성 후 주입시키는 방식이다. <br/>
> - 의존성이 줄어들며(변경에 있어서 비교적 덜 취약하다.) <br/>
> - 모의 객체의 주입이 가능해서 단위 테스트가 쉬워진다. <br/>
> - 가독성이 높아지고 재사용성 또한 높아진다.

3. JWT를 사용하여 인증/인가를 구현 했을 때의 장점은 무엇일까요? - 숙련주차의 답변을 Upgrade 해 주세요!
> 별도의 저장소를 필요로 하지 않아서 **서버자원** 의 절약이 가능하며, <br/>
> 인증 과정에서 다른 곳을 거칠 필요가 없어 효율적이다. 또한 인증정보를 가진 특정 서버에만 트래픽이 몰릴 일도 없어진다. <br/>
> 즉, 서버의 부하를 줄이기에 좋은 방식이다. <br/>
> 하지만 그럼에도 단점이 한계점이 존재하기 때문에 Access 토큰과 Refresh 토큰 이라는 것을 사용한다.(보안성 강화)
4. 반대로 JWT를 사용한 인증/인가의 한계점은 무엇일까요? - 숙련주차의 답변을 Upgrade 해 주세요!
> - 쿠키/세션과 다르게 토큰 자체의 데이터가 길어, 인증요청이 많아질수록 네트워크 부하가 심해질 우려가 있다. <br/>
> - 페이로드 자체는 암호화 되지 않기 때문에 유저의 중요한 정보는 담을 수 없다. <br/>
> - 토큰을 탈취당하면 대처가 어렵다. (그렇기에 사용기간 제한을 설정해준다.)

> - Access Token <br/>
> 짧은 유효기간을 가지며 토큰의 무효화 기능을 지원하지 않는 토큰 (보통 1시간)
> - Refresh Token <br/>
> 무효화 기능을 지원하고 긴 유효기간을 가지며 안전한 서버 저장소에 존재한다. (보통 2주) <br/><br/>
> **한번 로그인 할 시 이처럼 기존의 Access 토큰만을 발급하던 방식에서 두가지의 토큰을 발급하도록 바뀐다.**

> 이처럼 하는 이유는 jwt 특성인 stateless 즉, 클라이언트의 상태 정보를 가지지 않는 서버의 처리방식 때문이다. <br/><br/>
> Access 토큰의 유효기간이 지나면 사용자는 다시 발급이 가능한데 기존에는 매번 발급 받을 때 마다 처리하는 로직으로 사용시 매번 검증을 해야 해서 서버에 부하가 심해진다. <br/>
> 정상적인 로그인만 access 토큰을 발급하는데, 이말은 즉, Access 토큰의 발급을 위해서는 재로그인을 해야만 한다. <br/><br/>
> **Refresh 토큰이 존재하고 만약 Access 토큰의 유효기간 1시간이면, Refresh 토큰은 1시간에 한번만 사용되니 탈취 가능성도 대폭 줄이고 서부 부하도 줄일 수 있다.** <br/><br/>

</div>
</details>


<details>
<summary>심화 질문 2 및 답변</summary>
<div markdown="1">

1. Spring Security를 적용했을 때 어떤 점이 도움이 되셨나요?
2. Spring Security를 사용하지 않는다면 어떻게 인증/인가를 효율적으로 처리할 수 있을까요?
3. AOP에 대해 설명해 주세요!
4. RefreshToken 적용에 대한 장/단점을 작성해 주세요! 적용해 보지 않으셨다면 JWT를 사용하여 인증/인가를 구현 했을 때의 장/단점에 대해 숙련주차의 답변을 Upgrade 하여 작성해 주세요!
5. 즉시로딩 / 지연로딩에 대해 설명해 주세요!

</div>
</details>